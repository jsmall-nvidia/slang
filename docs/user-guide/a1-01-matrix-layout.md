---
layout: user-guide
---

Handling Matrix Layout Differences on Different Platforms
============================

The differences between default matrix layout or storage conventions between GLSL (OpenGL/Vulkan) and HLSL has been an issue that frequently causes confusion among developers. When writing applications that work on different targets, one important goal that developers frequently seek is to make it possible to pass the same matrix generated by host code to the same shader code, regardless of what graphics API is being used (e.g. Vulkan, OpenGL or Direct3D). As a solution to shader cross-compilation, Slang provides necessary tools for developers navigate around the differences between GLSL and HLSL targets.

A high level summary:

* Default matrix **layout** in memory for Slang in `column-major`. 
  * This default is for *legacy* reasons and may change in the future.
* Row-major layout is the only *portable* layout to use across targets. 
* Use `setMatrixLayoutMode`/`spSetMatrixLayoutMode`/`createSession` to set the default  
* Use `-matrix-layout-row-major` or `-matrix-layout-column-major` for the command line 
  * or via `spProcessCommandLineArguments`/`processCommandLineArguments`

On the portability issue, some targets *ignore* the matrix layout mode, notably CUDA and CPU/C++. For this reason for the widest breadth of targets and portability it is recommended to use *row-major* layout.

Two conventions of matrix transform math
-------------------------
Depending on the platform a developer is used to, a matrix-vector transform can be expressed as either `v*m` (`mul(v, m)` in HLSL), or `m*v` (`mul(m,v)` in HLSL). This convention, together with the matrix layout (column-major or row-major), determines how a matrix should be filled out in host code. 

In HLSL/Slang the order of vector and matrix parameters to `mul` determine how the *vector* is interpretted. This interpretation is required because a vector does not in as of it's self differentiate between being a row or a column. 

* `mul(v, m)` - v is interpretted as a row vector 
* `mul(m, v)` - v is interpretted as a column vector. 

Through this mechanism a developer is able to write transforms in their preferred style. 

These two styles are not directly interchangable - for a given `v` and `m` then generally `mul(v, m) != mul(m, v)`. That for that the matrix needs to be transposed so 

* `mul(v, m) == mul(transpose(m), v)`
* `mul(m, v) == mul(v, transpose(m))`

This behavior is *independent* of how a matrix layout in memory. Host code needs to be aware of how a shader code will interpret a matrix stored in memory, it's layout, as well as the convention is being used in shader code (ie `mul(v,m)` or `mul(m, v)`).

[Matrix layout](https://en.wikipedia.org/wiki/Row-_and_column-major_order) can be either row or column major. In `row major` and `column major` just determine which elements are contiguous i memory. `Row major` means the rows elements are contiguous. `Column major` means the column elements are contiguous.

Another way to think about this difference is in terms of where translation terms should be placed in memory when filling a typical 4x4 transform matrix. For `row-major` matrix layout, translation will be at `m + 12, 13, 14`. For a `column-major` matrix layout, translation will be at `m + 4, 7, 11`.

Slang automatically handles the convention differences when cross-compiling code to GLSL. For example, a `float3x4` matrix will be translated to `mat4x3` in the resulting GLSL. Correspondingly, `mul(v, m)` will be translated to `m*v` in GLSL. Therefore, as long as the user sticks to the above practices consistently, they will get correct result with the same matrix value in memory regardless of what graphics API they are actually using.

Overriding default matrix layout
--------------------------

Slang allows users to override default matrix layout with a compiler flag. 

For portability reasons it's recommended to use the 'row-major' layout - as that is the only style that will work on CUDA and C++/CPU targets. 

This compiler flag can be specified during the creation of a `Session`:
```
slang::IGlobalSession* globalSession;
...
slang::SessionDesc slangSessionDesc = {};
slangSessionDesc.defaultMatrixLayoutMode = SLANG_MATRIX_LAYOUT_COLUMN_MAJOR;
...
slang::ISession* session;
globalSession->createSession(slangSessionDesc, &session);
```

This makes Slang treat all matrices as in column-major layout, and for example emitting `column_major` qualifier in resulting HLSL code.

* Use `setMatrixLayoutMode`/`spSetMatrixLayoutMode` to set the default  
* Or use `-matrix-layout-row-major` or `-matrix-layout-column-major` for the command line (or parsed args)

Note that if you choose to use column-major layout, you either need to flip the matrix multiplication order in shader code or fill in the matrix in transpose order in host code.

Examples
--------

There are 4 variables:

* Host vector interpretation (row or column) - and therefore effective tranform order (column) `m * v` or (row) `v * m`
* Host matrix memory layout
* Shader vector interpretation (as determined via `mul(v, m)` or `mul(m, v)`
* Shader matrix memory layout 

The simplest scenario is that they are all `row-major`/`row vector`. In that case code will be most easily portable. NOTE! Currently this requires setting Slangs default matrix mode to `row-major`, as it's default is `column-major`. 

Also simple but *not* as portable is if they are all `column-major`/`column vector`. It is not portable because some targets (CUDA/C++/CPU) ignore `column-major` matrix layout.

If there is an inconsistency, then it may be necessary to transpose at the host/kernel boundary.

Any flip between conventions/layout is effectively a transpose, as long as there are an *even* number of `row-major layout`/`row vector interpretation`s then the expected results will be produced.  
